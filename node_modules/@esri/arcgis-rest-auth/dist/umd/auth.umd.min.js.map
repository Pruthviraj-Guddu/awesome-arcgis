{"version":3,"file":"auth.umd.min.js","sources":["../../src/fetch-token.ts","../../src/ApplicationSession.ts","../../src/generate-token.ts","../../src/UserSession.ts","../../src/get-user-url.ts"],"sourcesContent":["/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  IRequestOptions,\n  IFetchTokenParams,\n  ITokenRequestOptions\n} from \"@esri/arcgis-rest-request\";\n\ninterface IFetchTokenRawResponse {\n  access_token: string;\n  expires_in: number;\n  username: string;\n  ssl?: boolean;\n  refresh_token?: string;\n}\n\nexport interface IFetchTokenResponse {\n  token: string;\n  expires: Date;\n  username: string;\n  ssl: boolean;\n  refreshToken?: string;\n}\n\nexport function fetchToken(\n  url: string,\n  requestOptions: IFetchTokenParams | ITokenRequestOptions\n): Promise<IFetchTokenResponse> {\n  // TODO: remove union type and type guard next breaking change and just expect IGenerateTokenRequestOptions\n  const options: IRequestOptions = (requestOptions as ITokenRequestOptions)\n    .params\n    ? (requestOptions as IRequestOptions)\n    : { params: requestOptions };\n  // we generate a response, so we can't return the raw response\n  options.rawResponse = false;\n\n  return request(url, options).then((response: IFetchTokenRawResponse) => {\n    const r: IFetchTokenResponse = {\n      token: response.access_token,\n      username: response.username,\n      expires: new Date(\n        // convert seconds in response to milliseconds and add the value to the current time to calculate a static expiration timestamp\n        Date.now() + (response.expires_in * 1000 - 1000)\n      ),\n      ssl: response.ssl === true\n    };\n    if (response.refresh_token) {\n      r.refreshToken = response.refresh_token;\n    }\n\n    return r;\n  });\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  IAuthenticationManager,\n  ITokenRequestOptions\n} from \"@esri/arcgis-rest-request\";\nimport { fetchToken } from \"./fetch-token\";\n\nexport interface IApplicationSessionOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A Client Secret is also obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise. Treat it like a password.\n   */\n  clientSecret: string;\n\n  /**\n   * OAuth 2.0 access token from a previous application session.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  expires?: Date;\n\n  /**\n   * URL of ArcGIS REST base, defaults to \"https://www.arcgis.com/sharing/rest\"\n   */\n  portal?: string;\n\n  /**\n   * Duration of requested tokens in minutes. defaults to 7200 (5 days).\n   */\n  duration?: number;\n}\n\n/**\n * ```js\n * import { ApplicationSession } from '@esri/arcgis-rest-auth';\n * const session = new ApplicationSession({\n *   clientId: \"abc123\",\n *   clientSecret: \"sshhhhhh\"\n * })\n * // visit https://developers.arcgis.com to generate your own clientid and secret\n * ```\n * You can use [App Login](/arcgis-rest-js/guides/node/) to access premium content and services in ArcGIS Online.\n *\n */\nexport class ApplicationSession implements IAuthenticationManager {\n  public portal: string;\n  private clientId: string;\n  private clientSecret: string;\n  private token: string;\n  private expires: Date;\n  private duration: number;\n\n  /**\n   * Internal object to keep track of pending token requests. Used to prevent\n   *  duplicate token requests.\n   */\n  private _pendingTokenRequest: Promise<string>;\n\n  constructor(options: IApplicationSessionOptions) {\n    this.clientId = options.clientId;\n    this.clientSecret = options.clientSecret;\n    this.token = options.token;\n    this.expires = options.expires;\n    this.portal = options.portal || \"https://www.arcgis.com/sharing/rest\";\n    this.duration = options.duration || 7200;\n  }\n\n  // url isnt actually read or passed through.\n  public getToken(\n    url: string,\n    requestOptions?: ITokenRequestOptions\n  ): Promise<string> {\n    if (this.token && this.expires && this.expires.getTime() > Date.now()) {\n      return Promise.resolve(this.token);\n    }\n\n    if (this._pendingTokenRequest) {\n      return this._pendingTokenRequest;\n    }\n\n    this._pendingTokenRequest = this.refreshToken(requestOptions);\n\n    return this._pendingTokenRequest;\n  }\n\n  public refreshToken(requestOptions?: ITokenRequestOptions): Promise<string> {\n    const options = {\n      params: {\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        grant_type: \"client_credentials\",\n        expiration: this.duration\n      },\n      ...requestOptions\n    };\n    return fetchToken(`${this.portal}/oauth2/token/`, options).then(\n      response => {\n        this._pendingTokenRequest = null;\n        this.token = response.token;\n        this.expires = response.expires;\n        return response.token;\n      }\n    );\n  }\n\n  public refreshSession() {\n    return this.refreshToken().then(() => this);\n  }\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  IRequestOptions,\n  IGenerateTokenParams,\n  ITokenRequestOptions,\n  NODEJS_DEFAULT_REFERER_HEADER\n} from \"@esri/arcgis-rest-request\";\n\nexport interface IGenerateTokenResponse {\n  token: string;\n  expires: number;\n  ssl: boolean;\n}\n\nexport function generateToken(\n  url: string,\n  requestOptions: IGenerateTokenParams | ITokenRequestOptions\n): Promise<IGenerateTokenResponse> {\n  // TODO: remove union type and type guard next breaking change and just expect IGenerateTokenParams\n  const options: IRequestOptions = (requestOptions as ITokenRequestOptions)\n    .params\n    ? (requestOptions as IRequestOptions)\n    : { params: requestOptions };\n\n  /* istanbul ignore else */\n  if (\n    typeof window !== \"undefined\" &&\n    window.location &&\n    window.location.host\n  ) {\n    options.params.referer = window.location.host;\n  } else {\n    options.params.referer = NODEJS_DEFAULT_REFERER_HEADER;\n  }\n\n  return request(url, options);\n}\n","/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * /generateToken returns a token that cannot be refreshed.\n *\n * oauth2/token can return a token *and* a refreshToken.\n * up until the refreshToken expires, you can use it (and a clientId)\n * to fetch fresh credentials without a username and password.\n *\n * the catch is that this 'authorization_code' flow is only utilized\n * by server based OAuth 2 Node.js applications that call /authorize first.\n */\n\nimport * as http from \"http\";\nimport {\n  request,\n  IRequestOptions,\n  ArcGISAuthError,\n  IAuthenticationManager,\n  ITokenRequestOptions,\n  cleanUrl\n} from \"@esri/arcgis-rest-request\";\nimport { generateToken } from \"./generate-token\";\nimport { fetchToken, IFetchTokenResponse } from \"./fetch-token\";\nimport { IUser } from \"@esri/arcgis-rest-common-types\";\n\n/**\n * Internal utility for resolving a Promise from outside its constructor.\n *\n * See: http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/\n */\ninterface IDeferred<T> {\n  promise: Promise<T>;\n  resolve: (v: T) => void;\n  reject: (v: any) => void;\n}\n\nexport type AuthenticationProvider = \"arcgis\" | \"facebook\" | \"google\";\n\n/**\n * Represents a [credential]((https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html)) object used to access a secure ArcGIS resource.\n */\nexport interface ICredential {\n  expires: number;\n  server: string;\n  ssl: boolean;\n  token: string;\n  userId: string;\n}\n\nfunction defer<T>(): IDeferred<T> {\n  const deferred: any = {\n    promise: null,\n    resolve: null,\n    reject: null\n  };\n\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred as IDeferred<T>;\n}\n\n/**\n * Options for static OAuth 2.0 helper methods on `UserSession`.\n */\nexport interface IOauth2Options {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri: string;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n\n  provider?: AuthenticationProvider;\n\n  /**\n   * Duration (in minutes) that a token will be valid. Defaults to 20160 (two weeks).\n   */\n  duration?: number;\n\n  /**\n   * Determines whether to open the authorization window in a new tab/window or in the current window.\n   *\n   * @browserOnly\n   */\n  popup?: boolean;\n\n  /**\n   * Duration (in minutes) that a refresh token will be valid.\n   *\n   * @nodeOnly\n   */\n  refreshTokenTTL?: number;\n\n  /**\n   * The locale assumed to render the login page.\n   *\n   * @browserOnly\n   */\n  locale?: string;\n\n  /**\n   * Applications can specify an opaque value for this parameter to correlate the authorization request sent with the received response. By default, clientId is used.\n   *\n   * @browserOnly\n   */\n  state?: string;\n}\n\n/**\n * Options for the `UserSession` constructor.\n */\nexport interface IUserSessionOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId?: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri?: string;\n\n  /**\n   * OAuth 2.0 refresh token from a previous user session.\n   */\n  refreshToken?: string;\n\n  /**\n   * Expiration date of the `refreshToken`\n   */\n  refreshTokenExpires?: Date;\n\n  /**\n   * The authenticated user's username. Guaranteed to be unique across ArcGIS Online or your instance of ArcGIS Enterprise.\n   */\n  username?: string;\n\n  /**\n   * Password for this user. Used in CLI apps where users cannot do OAuth 2.0.\n   */\n  password?: string;\n\n  /**\n   * OAuth 2.0 access token from a previous user session.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  tokenExpires?: Date;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  ssl?: boolean;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n  provider?: AuthenticationProvider;\n\n  /**\n   * Duration of requested token validity in minutes. Used when requesting tokens with `username` and `password` or when validating the identity of unknown servers. Defaults to two weeks.\n   */\n  tokenDuration?: number;\n\n  /**\n   * Duration (in minutes) that a refresh token will be valid.\n   */\n  refreshTokenTTL?: number;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  server?: string;\n}\n\n/**\n * ```js\n * import { UserSession } from '@esri/arcgis-rest-auth';\n * UserSession.beginOAuth2({\n *   // register an app of your own to create a unique clientId\n *   clientId: \"abc123\",\n *   redirectUri: 'https://yourapp.com/authenticate.html'\n * })\n *   .then(session)\n * // or\n * new UserSession({\n *   username: \"jsmith\",\n *   password: \"123456\"\n * })\n * // or\n * UserSession.deserialize(cache)\n * ```\n * Used to authenticate both ArcGIS Online and ArcGIS Enterprise users. `UserSession` includes helper methods for [OAuth 2.0](/arcgis-rest-js/guides/browser-authentication/) in both browser and server applications.\n */\nexport class UserSession implements IAuthenticationManager {\n  /**\n   * Begins a new browser-based OAuth 2.0 sign in. If `options.popup` is true the\n   * authentication window will open in a new tab/window otherwise the user will\n   * be redirected to the authorization page in their current tab.\n   *\n   * @browserOnly\n   */\n  /* istanbul ignore next */\n  public static beginOAuth2(options: IOauth2Options, win: any = window) {\n    const {\n      portal,\n      provider,\n      clientId,\n      duration,\n      redirectUri,\n      popup,\n      state,\n      locale\n    }: IOauth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        provider: \"arcgis\",\n        duration: 20160,\n        popup: true,\n        state: options.clientId,\n        locale: \"\"\n      },\n      ...options\n    };\n    let url: string;\n    if (provider === \"arcgis\") {\n      url = `${portal}/oauth2/authorize?client_id=${clientId}&response_type=token&expiration=${duration}&redirect_uri=${encodeURIComponent(\n        redirectUri\n      )}&state=${state}&locale=${locale}`;\n    } else {\n      url = `${portal}/oauth2/social/authorize?client_id=${clientId}&socialLoginProviderName=${provider}&autoAccountCreateForSocial=true&response_type=token&expiration=${duration}&redirect_uri=${encodeURIComponent(\n        redirectUri\n      )}&state=${state}&locale=${locale}`;\n    }\n\n    if (!popup) {\n      win.location.href = url;\n      return undefined;\n    }\n\n    const session = defer<UserSession>();\n\n    win[`__ESRI_REST_AUTH_HANDLER_${clientId}`] = function(\n      errorString: any,\n      oauthInfoString: string\n    ) {\n      if (errorString) {\n        const error = JSON.parse(errorString);\n        session.reject(new ArcGISAuthError(error.errorMessage, error.error));\n        return;\n      }\n\n      if (oauthInfoString) {\n        const oauthInfo = JSON.parse(oauthInfoString);\n        session.resolve(\n          new UserSession({\n            clientId,\n            portal,\n            ssl: oauthInfo.ssl,\n            token: oauthInfo.token,\n            tokenExpires: new Date(oauthInfo.expires),\n            username: oauthInfo.username\n          })\n        );\n      }\n    };\n\n    win.open(\n      url,\n      \"oauth-window\",\n      \"height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes\"\n    );\n\n    return session.promise;\n  }\n\n  /**\n   * Completes a browser-based OAuth 2.0 sign if `options.popup` is true the user\n   * will be returned to the previous window. Otherwise a new `UserSession`\n   * will be returned.\n   *\n   * @browserOnly\n   */\n  /* istanbul ignore next */\n  public static completeOAuth2(options: IOauth2Options, win: any = window) {\n    const { portal, clientId }: IOauth2Options = {\n      ...{ portal: \"https://www.arcgis.com/sharing/rest\" },\n      ...options\n    };\n\n    function completeSignIn(error: any, oauthInfo?: IFetchTokenResponse) {\n      if (win.opener && win.opener.parent) {\n        win.opener.parent[`__ESRI_REST_AUTH_HANDLER_${clientId}`](\n          error ? JSON.stringify(error) : undefined,\n          JSON.stringify(oauthInfo)\n        );\n        win.close();\n        return undefined;\n      }\n\n      if (win !== win.parent) {\n        win.parent[`__ESRI_REST_AUTH_HANDLER_${clientId}`](\n          error ? JSON.stringify(error) : undefined,\n          JSON.stringify(oauthInfo)\n        );\n        win.close();\n        return undefined;\n      }\n\n      if (error) {\n        throw new ArcGISAuthError(error.errorMessage, error.error);\n      }\n\n      return new UserSession({\n        clientId,\n        portal,\n        ssl: oauthInfo.ssl,\n        token: oauthInfo.token,\n        tokenExpires: oauthInfo.expires,\n        username: oauthInfo.username\n      });\n    }\n\n    const match = win.location.href.match(\n      /access_token=(.+)&expires_in=(.+)&username=([^&]+)/\n    );\n\n    if (!match) {\n      const errorMatch = win.location.href.match(\n        /error=(.+)&error_description=(.+)/\n      );\n\n      const error = errorMatch[1];\n      const errorMessage = decodeURIComponent(errorMatch[2]);\n\n      return completeSignIn({ error, errorMessage });\n    }\n\n    const token = match[1];\n    const expires = new Date(\n      Date.now() + parseInt(match[2], 10) * 1000 - 60 * 1000\n    );\n    const username = decodeURIComponent(match[3]);\n    const ssl =\n      win.location.href.indexOf(\"&ssl=true\") > -1 ||\n      win.location.href.indexOf(\"#ssl=true\") > -1;\n\n    return completeSignIn(undefined, {\n      token,\n      expires,\n      ssl,\n      username\n    });\n  }\n\n  /**\n   * Begins a new server-based OAuth 2.0 sign in. This will redirect the user to\n   * the ArcGIS Online or ArcGIS Enterprise authorization page.\n   *\n   * @nodeOnly\n   */\n  public static authorize(\n    options: IOauth2Options,\n    response: http.ServerResponse\n  ) {\n    const { portal, clientId, duration, redirectUri }: IOauth2Options = {\n      ...{ portal: \"https://arcgis.com/sharing/rest\", duration: 20160 },\n      ...options\n    };\n\n    response.writeHead(301, {\n      Location: `${portal}/oauth2/authorize?client_id=${clientId}&duration=${duration}&response_type=code&redirect_uri=${encodeURIComponent(\n        redirectUri\n      )}`\n    });\n\n    response.end();\n  }\n\n  /**\n   * Completes the server-based OAuth 2.0 sign in process by exchanging the `authorizationCode`\n   * for a `access_token`.\n   *\n   * @nodeOnly\n   */\n  public static exchangeAuthorizationCode(\n    options: IOauth2Options,\n    authorizationCode: string\n  ): Promise<UserSession> {\n    const { portal, clientId, redirectUri, refreshTokenTTL }: IOauth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        refreshTokenTTL: 1440\n      },\n      ...options\n    };\n\n    return fetchToken(`${portal}/oauth2/token`, {\n      grant_type: \"authorization_code\",\n      client_id: clientId,\n      redirect_uri: redirectUri,\n      code: authorizationCode\n    }).then(response => {\n      return new UserSession({\n        clientId,\n        portal,\n        ssl: response.ssl,\n        redirectUri,\n        refreshToken: response.refreshToken,\n        refreshTokenTTL,\n        refreshTokenExpires: new Date(\n          Date.now() + (refreshTokenTTL - 1) * 1000\n        ),\n        token: response.token,\n        tokenExpires: response.expires,\n        username: response.username\n      });\n    });\n  }\n\n  public static deserialize(str: string) {\n    const options = JSON.parse(str);\n    return new UserSession({\n      clientId: options.clientId,\n      refreshToken: options.refreshToken,\n      refreshTokenExpires: new Date(options.refreshTokenExpires),\n      username: options.username,\n      password: options.password,\n      token: options.token,\n      tokenExpires: new Date(options.tokenExpires),\n      portal: options.portal,\n      ssl: options.ssl,\n      tokenDuration: options.tokenDuration,\n      redirectUri: options.redirectUri,\n      refreshTokenTTL: options.refreshTokenTTL\n    });\n  }\n\n  /**\n   * Translates authentication from the format used in the [ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/).\n   *\n   * ```js\n   * UserSession.fromCredential({\n   *   userId: \"jsmith\",\n   *   token: \"secret\"\n   * });\n   * ```\n   *\n   * @returns UserSession\n   */\n  public static fromCredential(credential: ICredential) {\n    return new UserSession({\n      portal: credential.server.includes(\"sharing/rest\")\n        ? credential.server\n        : credential.server + `/sharing/rest`,\n      ssl: credential.ssl,\n      token: credential.token,\n      username: credential.userId,\n      tokenExpires: new Date(credential.expires)\n    });\n  }\n\n  /**\n   * Client ID being used for authentication if provided in the `constructor`.\n   */\n  public readonly clientId: string;\n\n  /**\n   * The currently authenticated user if provided in the `constructor`.\n   */\n  public readonly username: string;\n\n  /**\n   * The currently authenticated user's password if provided in the `constructor`.\n   */\n  public readonly password: string;\n\n  /**\n   * The current portal the user is authenticated with.\n   */\n  public readonly portal: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  public readonly ssl: boolean;\n\n  /**\n   * The authentication provider to use.\n   */\n  public readonly provider: AuthenticationProvider;\n\n  /**\n   * Determines how long new tokens requested are valid.\n   */\n  public readonly tokenDuration: number;\n\n  /**\n   * A valid redirect URI for this application if provided in the `constructor`.\n   */\n  public readonly redirectUri: string;\n\n  /**\n   * Duration of new OAuth 2.0 refresh token validity.\n   */\n  public readonly refreshTokenTTL: number;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  public readonly server: string;\n\n  /**\n   * Hydrated by a call to [getUser()](#getUser-summary).\n   */\n  private _user: IUser;\n\n  private _token: string;\n  private _tokenExpires: Date;\n  private _refreshToken: string;\n  private _refreshTokenExpires: Date;\n\n  /**\n   * Internal object to keep track of pending token requests. Used to prevent\n   *  duplicate token requests.\n   */\n  private _pendingTokenRequests: {\n    [key: string]: Promise<string>;\n  };\n\n  /**\n   * Internal list of trusted 3rd party servers (federated servers) that have\n   *  been validated with `generateToken`.\n   */\n  private trustedServers: {\n    [key: string]: {\n      token: string;\n      expires: Date;\n    };\n  };\n\n  /**\n   * The current ArcGIS Online or ArcGIS Enterprise `token`.\n   */\n  get token() {\n    return this._token;\n  }\n\n  /**\n   * The expiration time of the current `token`.\n   */\n  get tokenExpires() {\n    return this._tokenExpires;\n  }\n\n  /**\n   * The current token to ArcGIS Online or ArcGIS Enterprise.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n\n  /**\n   * The expiration time of the current `refreshToken`.\n   */\n  get refreshTokenExpires() {\n    return this._refreshTokenExpires;\n  }\n\n  constructor(options: IUserSessionOptions) {\n    this.clientId = options.clientId;\n    this._refreshToken = options.refreshToken;\n    this._refreshTokenExpires = options.refreshTokenExpires;\n    this.username = options.username;\n    this.password = options.password;\n    this._token = options.token;\n    this._tokenExpires = options.tokenExpires;\n    this.portal = options.portal\n      ? cleanUrl(options.portal)\n      : \"https://www.arcgis.com/sharing/rest\";\n    this.ssl = options.ssl;\n    this.provider = options.provider || \"arcgis\";\n    this.tokenDuration = options.tokenDuration || 20160;\n    this.redirectUri = options.redirectUri;\n    this.refreshTokenTTL = options.refreshTokenTTL || 1440;\n\n    this.trustedServers = {};\n    // if a non-federated server was passed explicitly, it should be trusted.\n    if (options.server) {\n      // if the url includes more than '/arcgis/', trim the rest\n      const [serverRoot] = options.server\n        .toLowerCase()\n        .split(/\\/rest(\\/admin)?\\/services\\//);\n      this.trustedServers[serverRoot] = {\n        token: options.token,\n        expires: options.tokenExpires\n      };\n    }\n    this._pendingTokenRequests = {};\n  }\n\n  /**\n   * Returns authentication in a format useable in the [ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/).\n   *\n   * ```js\n   * esriId.registerToken(session.toCredential());\n   * ```\n   *\n   * @returns ICredential\n   */\n  public toCredential(): ICredential {\n    return {\n      expires: this.tokenExpires.getTime(),\n      server: this.portal,\n      ssl: this.ssl,\n      token: this.token,\n      userId: this.username\n    };\n  }\n\n  /**\n   * Returns information about the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic.\n   *\n   * ```js\n   * session.getUser()\n   *   .then(response => {\n   *     console.log(response.role); // \"org_admin\"\n   *   })\n   * ```\n   *\n   * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n   * @returns A Promise that will resolve with the data from the response.\n   */\n  public getUser(requestOptions?: IRequestOptions): Promise<IUser> {\n    if (this._user && this._user.username === this.username) {\n      return Promise.resolve(this._user);\n    } else {\n      const url = `${this.portal}/community/users/${encodeURIComponent(\n        this.username\n      )}`;\n\n      const options = {\n        httpMethod: \"GET\",\n        authentication: this,\n        ...requestOptions,\n        rawResponse: false\n      } as IRequestOptions;\n      return request(url, options).then(response => {\n        this._user = response;\n        return response;\n      });\n    }\n  }\n\n  /**\n   * Gets an appropriate token for the given URL. If `portal` is ArcGIS Online and\n   * the request is to an ArcGIS Online domain `token` will be used. If the request\n   * is to the current `portal` the current `token` will also be used. However if\n   * the request is to an unknown server we will validate the server with a request\n   * to our current `portal`.\n   */\n  public getToken(url: string, requestOptions?: ITokenRequestOptions) {\n    if (\n      /^https?:\\/\\/\\S+\\.arcgis\\.com\\/sharing\\/rest/.test(this.portal) &&\n      /^https?:\\/\\/\\S+\\.arcgis\\.com.+/.test(url)\n    ) {\n      return this.getFreshToken(requestOptions);\n    } else if (new RegExp(this.portal, \"i\").test(url)) {\n      return this.getFreshToken(requestOptions);\n    } else {\n      return this.getTokenForServer(url, requestOptions);\n    }\n  }\n\n  public toJSON(): IUserSessionOptions {\n    return {\n      clientId: this.clientId,\n      refreshToken: this.refreshToken,\n      refreshTokenExpires: this.refreshTokenExpires,\n      username: this.username,\n      password: this.password,\n      token: this.token,\n      tokenExpires: this.tokenExpires,\n      portal: this.portal,\n      ssl: this.ssl,\n      tokenDuration: this.tokenDuration,\n      redirectUri: this.redirectUri,\n      refreshTokenTTL: this.refreshTokenTTL\n    };\n  }\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Manually refreshes the current `token` and `tokenExpires`.\n   */\n  public refreshSession(\n    requestOptions?: ITokenRequestOptions\n  ): Promise<UserSession> {\n    // make sure subsequent calls to getUser() don't returned cached metadata\n    this._user = null;\n    if (this.username && this.password) {\n      return this.refreshWithUsernameAndPassword(requestOptions);\n    }\n\n    if (this.clientId && this.refreshToken) {\n      return this.refreshWithRefreshToken();\n    }\n\n    return Promise.reject(new ArcGISAuthError(\"Unable to refresh token.\"));\n  }\n\n  /**\n   * Validates that a given URL is properly federated with our current `portal`.\n   * Attempts to use the internal `trustedServers` cache first.\n   */\n  private getTokenForServer(\n    url: string,\n    requestOptions?: ITokenRequestOptions\n  ) {\n    // requests to /rest/services/ and /rest/admin/services/ are both valid\n    // Federated servers may have inconsistent casing, so lowerCase it\n    const [root] = url.toLowerCase().split(/\\/rest(\\/admin)?\\/services\\//);\n    const existingToken = this.trustedServers[root];\n\n    if (\n      existingToken &&\n      existingToken.expires &&\n      existingToken.expires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(existingToken.token);\n    }\n\n    if (this._pendingTokenRequests[root]) {\n      return this._pendingTokenRequests[root];\n    }\n\n    this._pendingTokenRequests[root] = request(`${root}/rest/info`)\n      .then(response => {\n        if (response.owningSystemUrl) {\n          /**\n           * if this server is not owned by this portal\n           * bail out with an error since we know we wont\n           * be able to generate a token\n           */\n          if (!new RegExp(response.owningSystemUrl, \"i\").test(this.portal)) {\n            throw new ArcGISAuthError(\n              `${url} is not federated with ${this.portal}.`,\n              \"NOT_FEDERATED\"\n            );\n          } else {\n            /**\n             * if the server is federated, use the relevant token endpoint.\n             */\n            return request(\n              `${response.owningSystemUrl}/sharing/rest/info`,\n              requestOptions\n            );\n          }\n        } else if (\n          response.authInfo &&\n          this.trustedServers[root] !== undefined\n        ) {\n          /**\n           * if its a stand-alone instance of ArcGIS Server that doesn't advertise\n           * federation, but the root server url is recognized, use its built in token endpoint.\n           */\n          return Promise.resolve({ authInfo: response.authInfo });\n        } else {\n          throw new ArcGISAuthError(\n            `${url} is not federated with any portal and is not explicitly trusted.`,\n            \"NOT_FEDERATED\"\n          );\n        }\n      })\n      .then((response: any) => {\n        return response.authInfo.tokenServicesUrl;\n      })\n      .then((tokenServicesUrl: string) => {\n        // an expired token cant be used to generate a new token\n        if (this.token && this.tokenExpires.getTime() > Date.now()) {\n          return generateToken(tokenServicesUrl, {\n            params: {\n              token: this.token,\n              serverUrl: url,\n              expiration: this.tokenDuration,\n              client: \"referer\"\n            }\n          });\n          // generate an entirely fresh token if necessary\n        } else {\n          return generateToken(tokenServicesUrl, {\n            params: {\n              username: this.username,\n              password: this.password,\n              expiration: this.tokenDuration,\n              client: \"referer\"\n            }\n          }).then((response: any) => {\n            this._token = response.token;\n            this._tokenExpires = new Date(response.expires);\n            return response;\n          });\n        }\n      })\n      .then(response => {\n        this.trustedServers[root] = {\n          expires: new Date(response.expires),\n          token: response.token\n        };\n        return response.token;\n      });\n\n    return this._pendingTokenRequests[root];\n  }\n\n  /**\n   * Returns an unexpired token for the current `portal`.\n   */\n  private getFreshToken(requestOptions?: ITokenRequestOptions) {\n    if (\n      this.token &&\n      this.tokenExpires &&\n      this.tokenExpires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(this.token);\n    }\n\n    if (!this._pendingTokenRequests[this.portal]) {\n      this._pendingTokenRequests[this.portal] = this.refreshSession(\n        requestOptions\n      ).then(session => {\n        this._pendingTokenRequests[this.portal] = null;\n        return session.token;\n      });\n    }\n\n    return this._pendingTokenRequests[this.portal];\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `username` and\n   * `password`.\n   */\n  private refreshWithUsernameAndPassword(\n    requestOptions?: ITokenRequestOptions\n  ) {\n    const options = {\n      params: {\n        username: this.username,\n        password: this.password,\n        expiration: this.tokenDuration\n      },\n      ...requestOptions\n    };\n    return generateToken(`${this.portal}/generateToken`, options).then(\n      (response: any) => {\n        this._token = response.token;\n        this._tokenExpires = new Date(response.expires);\n        return this;\n      }\n    );\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `refreshToken`.\n   */\n  private refreshWithRefreshToken(requestOptions?: ITokenRequestOptions) {\n    if (\n      this.refreshToken &&\n      this.refreshTokenExpires &&\n      this.refreshTokenExpires.getTime() < Date.now()\n    ) {\n      return this.refreshRefreshToken(requestOptions);\n    }\n\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        grant_type: \"refresh_token\"\n      },\n      ...requestOptions\n    };\n    return fetchToken(`${this.portal}/oauth2/token`, options).then(response => {\n      this._token = response.token;\n      this._tokenExpires = response.expires;\n      return this;\n    });\n  }\n\n  /**\n   * Exchanges an unexpired `refreshToken` for a new one, also updates `token` and\n   * `tokenExpires`.\n   */\n  private refreshRefreshToken(requestOptions?: ITokenRequestOptions) {\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        redirect_uri: this.redirectUri,\n        grant_type: \"exchange_refresh_token\"\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token`, options).then(response => {\n      this._token = response.token;\n      this._tokenExpires = response.expires;\n      this._refreshToken = response.refreshToken;\n      this._refreshTokenExpires = new Date(\n        Date.now() + (this.refreshTokenTTL - 1) * 60 * 1000\n      );\n      return this;\n    });\n  }\n}\n","/* Copyright (c) 2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { getPortalUrl } from \"@esri/arcgis-rest-request\";\nimport { UserSession } from \"./UserSession\";\n\n/**\n * Helper that returns the [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm) for a given portal.\n *\n * @param session\n * @returns User url to be used in API requests.\n */\nexport function getUserUrl(session: UserSession): string {\n  return `${getPortalUrl(session)}/community/users/${encodeURIComponent(\n    session.username\n  )}`;\n}\n"],"names":["url","requestOptions","options","params","rawResponse","request","then","response","r","token","access_token","username","expires","Date","now","expires_in","ssl","refresh_token","refreshToken","this","clientId","clientSecret","portal","duration","ApplicationSession","getTime","Promise","resolve","_pendingTokenRequest","client_id","client_secret","grant_type","expiration","fetchToken","_this","window","location","host","referer","NODEJS_DEFAULT_REFERER_HEADER","_refreshToken","_refreshTokenExpires","refreshTokenExpires","password","_token","_tokenExpires","tokenExpires","cleanUrl","provider","tokenDuration","redirectUri","refreshTokenTTL","trustedServers","server","serverRoot","_pendingTokenRequests","UserSession","win","_a","popup","state","locale","encodeURIComponent","deferred","session","promise","reject","errorString","oauthInfoString","error","JSON","parse","ArcGISAuthError","errorMessage","oauthInfo","open","href","opener","parent","stringify","undefined","close","match","errorMatch","completeSignIn","decodeURIComponent","parseInt","indexOf","writeHead","Location","end","authorizationCode","redirect_uri","code","str","credential","includes","userId","Object","_user","tslib_1.__assign","httpMethod","authentication","test","getFreshToken","RegExp","getTokenForServer","refreshWithUsernameAndPassword","refreshWithRefreshToken","root","existingToken","owningSystemUrl","authInfo","tokenServicesUrl","generateToken","serverUrl","client","refreshSession","refreshRefreshToken","getPortalUrl"],"mappings":"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"}